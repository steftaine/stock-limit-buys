// State
let currentStock = {
    symbol: '',
    price: 0,
    data: [],
    meta: {}
};

const WATCHLIST = ['NVDA', 'MSFT', 'BTC-USD', 'SMCI', 'META', 'GOOG'];

let chartInstance = null;

// DOM Elements
const elements = {
    // Views
    dashboardView: document.getElementById('dashboardView'),
    detailView: document.getElementById('detailView'),
    dashboardList: document.getElementById('dashboardList'),
    backBtn: document.getElementById('backBtn'),
    logoBtn: document.getElementById('logoBtn'),

    // Search
    search: document.getElementById('stockSearch'),
    search: document.getElementById('stockSearch'),
    searchBtn: document.getElementById('searchBtn'),
    refreshBtn: document.getElementById('refreshBtn'),
    lastUpdated: document.getElementById('lastUpdated'),

    // Detail View Elements
    ticker: document.getElementById('currentTicker'),
    price: document.getElementById('currentPrice'),
    change: document.getElementById('priceChange'),
    levelsList: document.getElementById('levelsList'),
    chartCanvas: document.getElementById('stockChart'),
    rsi: document.getElementById('rsiValue'),
    topSignalValue: document.getElementById('topSignalValue'),
    topSignalStatus: document.getElementById('topSignalStatus'),
    buyQualityValue: document.getElementById('buyQualityValue'),
    buyQualityStatus: document.getElementById('buyQualityStatus'),
    maExtension: document.getElementById('maExtension'),
    volume: document.getElementById('volume')
};

// Technical Indicators
const calculateRSI = (prices, period = 14) => {
    if (!prices || prices.length < period + 1) return null;

    let gains = 0;
    let losses = 0;
    const rsiSeries = [];

    // First RSI
    for (let i = 1; i <= period; i++) {
        const change = prices[i] - prices[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
    }

    let avgGain = gains / period;
    let avgLoss = losses / period;

    // Push initial nulls for alignment
    for (let i = 0; i < period; i++) rsiSeries.push(null);

    let rs = avgGain / avgLoss;
    rsiSeries.push(avgLoss === 0 ? 100 : 100 - (100 / (1 + rs)));

    // Calculate for the rest
    for (let i = period + 1; i < prices.length; i++) {
        const change = prices[i] - prices[i - 1];
        const gain = change > 0 ? change : 0;
        const loss = change < 0 ? -change : 0;

        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        rs = avgGain / avgLoss;
        rsiSeries.push(avgLoss === 0 ? 100 : 100 - (100 / (1 + rs)));
    }

    return rsiSeries;
};

const calculateSMA = (prices, period = 200) => {
    if (!prices || prices.length < period) return null;
    // Return last value for stats
    const slice = prices.slice(-period);
    const sum = slice.reduce((a, b) => a + b, 0);
    return sum / period;
};

const calculateSMASeries = (prices, period = 200) => {
    if (!prices || prices.length < period) return [];
    const smaSeries = [];
    // Push nulls
    for (let i = 0; i < period - 1; i++) smaSeries.push(null);

    for (let i = period - 1; i < prices.length; i++) {
        const slice = prices.slice(i - period + 1, i + 1);
        const sum = slice.reduce((a, b) => a + b, 0);
        smaSeries.push(sum / period);
    }
    return smaSeries;
};

// RSI Divergence Detection
const detectRSIDivergence = (prices, rsiSeries) => {
    if (!prices || !rsiSeries || prices.length < 30) return false;

    // Find last 2 local maxima in price and RSI
    const priceMaxima = [];
    const rsiMaxima = [];

    // Start from end, go backwards
    for (let i = prices.length - 2; i > 5; i--) {
        // Price maximum: higher than neighbors
        if (prices[i] > prices[i - 1] && prices[i] > prices[i + 1] &&
            prices[i] > prices[i - 2] && prices[i] > prices[i + 2]) {
            priceMaxima.push({ index: i, value: prices[i] });
            if (priceMaxima.length >= 2) break;
        }
    }

    for (let i = rsiSeries.length - 2; i > 5; i--) {
        if (!rsiSeries[i]) continue;
        // RSI maximum: higher than neighbors
        if (rsiSeries[i] > rsiSeries[i - 1] && rsiSeries[i] > rsiSeries[i + 1] &&
            rsiSeries[i] > rsiSeries[i - 2] && rsiSeries[i] > rsiSeries[i + 2]) {
            rsiMaxima.push({ index: i, value: rsiSeries[i] });
            if (rsiMaxima.length >= 2) break;
        }
    }

    // Check for bearish divergence
    if (priceMaxima.length >= 2 && rsiMaxima.length >= 2) {
        const latestPricePeak = priceMaxima[0].value;
        const prevPricePeak = priceMaxima[1].value;
        const latestRSIPeak = rsiMaxima[0].value;
        const prevRSIPeak = rsiMaxima[1].value;

        // Bearish divergence: price makes new high, RSI doesn't
        if (latestPricePeak > prevPricePeak && latestRSIPeak < prevRSIPeak) {
            return true;
        }
    }

    return false;
};

// Volume Distribution Analysis
const detectDistributionVolume = (prices, volumes) => {
    if (!prices || !volumes || prices.length < 20) return false;

    // Calculate average volume over last 20 periods
    const recentVolumes = volumes.slice(-20);
    const avgVolume = recentVolumes.reduce((a, b) => a + b, 0) / recentVolumes.length;

    // Check last 5 days for distribution pattern
    let distributionDays = 0;
    for (let i = prices.length - 5; i < prices.length - 1; i++) {
        const isDownDay = prices[i] < prices[i - 1];
        const isHighVolume = volumes[i] > (avgVolume * 1.5);

        if (isDownDay && isHighVolume) {
            distributionDays++;
        }
    }

    // If 2+ out of last 5 days show distribution, flag it
    return distributionDays >= 2;
};

// Bullish RSI Divergence Detection (inverse of bearish)
const detectBullishRSIDivergence = (prices, rsiSeries) => {
    if (!prices || !rsiSeries || prices.length < 30) return false;

    // Find last 2 local minima in price and RSI
    const priceMinima = [];
    const rsiMinima = [];

    // Start from end, go backwards
    for (let i = prices.length - 2; i > 5; i--) {
        // Price minimum: lower than neighbors
        if (prices[i] < prices[i - 1] && prices[i] < prices[i + 1] &&
            prices[i] < prices[i - 2] && prices[i] < prices[i + 2]) {
            priceMinima.push({ index: i, value: prices[i] });
            if (priceMinima.length >= 2) break;
        }
    }

    for (let i = rsiSeries.length - 2; i > 5; i--) {
        if (!rsiSeries[i]) continue;
        // RSI minimum: lower than neighbors
        if (rsiSeries[i] < rsiSeries[i - 1] && rsiSeries[i] < rsiSeries[i + 1] &&
            rsiSeries[i] < rsiSeries[i - 2] && rsiSeries[i] < rsiSeries[i + 2]) {
            rsiMinima.push({ index: i, value: rsiSeries[i] });
            if (rsiMinima.length >= 2) break;
        }
    }

    // Check for bullish divergence
    if (priceMinima.length >= 2 && rsiMinima.length >= 2) {
        const latestPriceLow = priceMinima[0].value;
        const prevPriceLow = priceMinima[1].value;
        const latestRSILow = rsiMinima[0].value;
        const prevRSILow = rsiMinima[1].value;

        // Bullish divergence: price makes new low, RSI doesn't
        if (latestPriceLow < prevPriceLow && latestRSILow > prevRSILow) {
            return true;
        }
    }

    return false;
};

// Accumulation Volume Analysis (inverse of distribution)
const detectAccumulationVolume = (prices, volumes) => {
    if (!prices || !volumes || prices.length < 20) return false;

    // Calculate average volume over last 20 periods
    const recentVolumes = volumes.slice(-20);
    const avgVolume = recentVolumes.reduce((a, b) => a + b, 0) / recentVolumes.length;

    // Check last 5 days for accumulation pattern
    let accumulationDays = 0;
    for (let i = prices.length - 5; i < prices.length - 1; i++) {
        const isUpDay = prices[i] > prices[i - 1];
        const isHighVolume = volumes[i] > (avgVolume * 1.5);

        if (isUpDay && isHighVolume) {
            accumulationDays++;
        }
    }

    // If 2+ out of last 5 days show accumulation, flag it
    return accumulationDays >= 2;
};

// Calculate Rate of Change (Momentum)
const calculateMomentum = (prices, period = 10) => {
    if (!prices || prices.length < period) return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - period];
    return ((current - past) / past) * 100;
};

// Calculate Acceleration (2nd derivative of price)
const calculateAcceleration = (prices) => {
    if (!prices || prices.length < 20) return 0;

    // Recent momentum (last 10 days)
    const recentMomentum = calculateMomentum(prices, 10);
    // Prior momentum (10-20 days ago)
    const priorPrices = prices.slice(-20, -10);
    const priorMomentum = calculateMomentum(priorPrices, 10);

    // Acceleration = change in momentum
    return recentMomentum - priorMomentum;
};

// Detect Recent Volatility Expansion
const detectVolatilityExpansion = (prices) => {
    if (!prices || prices.length < 30) return false;

    // Calculate average true range for recent vs historical
    const recentPrices = prices.slice(-10);
    const historicalPrices = prices.slice(-30, -10);

    const calcATR = (priceArray) => {
        let sum = 0;
        for (let i = 1; i < priceArray.length; i++) {
            sum += Math.abs(priceArray[i] - priceArray[i - 1]);
        }
        return sum / (priceArray.length - 1);
    };

    const recentATR = calcATR(recentPrices);
    const historicalATR = calcATR(historicalPrices);

    // Volatility expansion if recent ATR > 1.5x historical
    return recentATR > (historicalATR * 1.5);
};

// Detect Market Phase
const detectMarketPhase = (prices, rsi, extension, topSignalScore, buyQualityScore, volumes) => {
    if (!prices || prices.length < 30) return 'INSUFFICIENT DATA';

    const momentum = calculateMomentum(prices, 10);
    const acceleration = calculateAcceleration(prices);
    const volatilityExpanding = detectVolatilityExpansion(prices);

    // 1. EUPHORIC VERTICAL (Parabolic top)
    if (topSignalScore >= 7 && acceleration > 5 && volatilityExpanding) {
        return 'EUPHORIC VERTICAL';
    }

    // 2. CRASH/CAPITULATION (Panic selling)
    if (buyQualityScore >= 8 && rsi < 25 && volatilityExpanding && momentum < -15) {
        return 'CRASH/CAPITULATION';
    }

    // 3. MELT-UP MODE (Late-stage parabolic, not yet peaked)
    if (topSignalScore >= 4 && topSignalScore < 7 && momentum > 10 && rsi > 65 && acceleration > 2) {
        return 'MELT-UP MODE';
    }

    // 4. ACCUMULATION (Bottoming process)
    if (buyQualityScore >= 5 && rsi < 45 && Math.abs(momentum) < 5) {
        return 'ACCUMULATION';
    }

    // 5. DOWNWARD TREND (Bear market)
    if (rsi < 50 && momentum < -5 && extension < 0) {
        return 'DOWNWARD TREND';
    }

    // 6. UPWARD TREND (Healthy bull)
    if (rsi >= 50 && rsi <= 70 && momentum > 2 && topSignalScore < 4) {
        return 'UPWARD TREND';
    }

    // Default: Neutral/Sideways
    return 'NEUTRAL';
};

// ===== MELTUP EXIT ENGINE LOGIC =====

// Global State for "Soft" Metrics
const marketState = {
    mediaTone: 'Strong', // Default
    fearGreedIndex: 75, // Default
    btcFundingRates: 'Normal', // Default
    btcSocialVolume: 'Normal',
    analystCommentary: 'Bullish',
    isRealTime: {
        mediaTone: false,
        fearGreed: false,
        funding: false
    }
};

// Real-Time Data Fetchers
const fetchRealTimeData = async (symbol) => {
    console.log("Fetching real-time soft metrics...");

    // 1. Fear & Greed Index
    try {
        const fgRes = await fetch('https://api.allorigins.win/raw?url=https://api.alternative.me/fng/');
        const fgData = await fgRes.json();
        if (fgData.data && fgData.data.length > 0) {
            marketState.fearGreedIndex = parseInt(fgData.data[0].value);
            marketState.isRealTime.fearGreed = true;
            updateSimulationUI('fearGreed');
        }
    } catch (e) {
        console.error("Error fetching Fear & Greed:", e);
    }

    // 2. BTC Funding Rates (BitMEX)
    try {
        const fundRes = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://www.bitmex.com/api/v1/instrument?symbol=XBTUSD&count=1&reverse=true&columns=fundingRate'));
        const fundData = await fundRes.json();
        if (fundData && fundData.length > 0) {
            const rate = fundData[0].fundingRate;
            // Threshold: > 0.05% (0.0005) is high/spike for 8h rate
            marketState.btcFundingRates = rate > 0.0005 ? 'Spike' : 'Normal';
            marketState.isRealTime.funding = true;
            updateSimulationUI('funding');
        }
    } catch (e) {
        console.error("Error fetching Funding Rate:", e);
    }

    // 3. Media Tone (Finnhub News)
    if (symbol) {
        try {
            const apiKey = 'd4j86r1r01queualuh3gd4j86r1r01queualuh40';
            // Get news for last 3 days
            const today = new Date();
            const threeDaysAgo = new Date();
            threeDaysAgo.setDate(today.getDate() - 3);
            const fromDate = threeDaysAgo.toISOString().split('T')[0];
            const toDate = today.toISOString().split('T')[0];

            const newsUrl = `https://finnhub.io/api/v1/company-news?symbol=${symbol}&from=${fromDate}&to=${toDate}&token=${apiKey}`;
            const newsRes = await fetch(newsUrl);
            const newsData = await newsRes.json();

            if (newsData && newsData.length > 0) {
                let score = 0;
                const headlines = newsData.slice(0, 15).map(n => n.headline.toLowerCase() + " " + n.summary.toLowerCase());

                const keywords = {
                    transformative: ['revolution', 'transform', 'paradigm', 'unstoppable', 'forever', 'era', 'ai', 'dominant', 'redefining'],
                    strong: ['beat', 'surge', 'record', 'high', 'growth', 'jump', 'rally', 'soar'],
                    uncertain: ['warning', 'risk', 'bubble', 'caution', 'volatility', 'sold', 'uncertain', 'doubt'],
                    overextended: ['crash', 'collapse', 'plummet', 'bear', 'sell', 'correction', 'overbought']
                };

                headlines.forEach(text => {
                    keywords.transformative.forEach(w => { if (text.includes(w)) score += 2; });
                    keywords.strong.forEach(w => { if (text.includes(w)) score += 1; });
                    keywords.uncertain.forEach(w => { if (text.includes(w)) score -= 1.5; });
                    keywords.overextended.forEach(w => { if (text.includes(w)) score -= 3; });
                });

                // Normalize Score
                if (score >= 10) marketState.mediaTone = 'Transformative';
                else if (score >= 5) marketState.mediaTone = 'Strong';
                else if (score <= -5) marketState.mediaTone = 'Overextended';
                else if (score <= -2) marketState.mediaTone = 'Uncertain';
                else marketState.mediaTone = 'Strong'; // Default fallback if neutral but generally bullish market

                marketState.isRealTime.mediaTone = true;
                updateSimulationUI('mediaTone');
            }
        } catch (e) {
            console.error("Error fetching Media Tone:", e);
        }
    }
};

// Helper to update UI inputs when real-time data arrives
const updateSimulationUI = (type) => {
    const mediaSelect = document.getElementById('simMediaTone');
    const fearRange = document.getElementById('simFearGreed');
    const fearValue = document.getElementById('simFearGreedValue');
    const fundingSelect = document.getElementById('simFunding');

    if (type === 'mediaTone' && mediaSelect) {
        mediaSelect.value = marketState.mediaTone;
        addLiveIndicator(mediaSelect);
    }
    if (type === 'fearGreed' && fearRange) {
        fearRange.value = marketState.fearGreedIndex;
        if (fearValue) fearValue.textContent = marketState.fearGreedIndex;
        addLiveIndicator(fearRange.parentElement); // Add to container
    }
    if (type === 'funding' && fundingSelect) {
        fundingSelect.value = marketState.btcFundingRates;
        addLiveIndicator(fundingSelect);
    }
};

const addLiveIndicator = (element) => {
    // Check if already has indicator
    if (element.parentNode.querySelector('.live-indicator')) return;

    const span = document.createElement('span');
    span.className = 'live-indicator';
    span.innerHTML = '● LIVE';
    span.style.color = 'var(--success)';
    span.style.fontSize = '10px';
    span.style.fontWeight = 'bold';
    span.style.marginLeft = '8px';
    span.style.animation = 'pulse 2s infinite';

    // Insert after label if possible, or append
    const label = element.parentNode.querySelector('label');
    if (label) {
        label.appendChild(span);
    }
};

// 1. System Activation Condition
const checkSystemActivation = (prices, rsi, acceleration) => {
    if (!prices || prices.length < 130) return false; // Need ~6 months

    // Price +40% from 6 month low
    const sixMonthPrices = prices.slice(-126); // ~6 months (21 * 6)
    const sixMonthLow = Math.min(...sixMonthPrices);
    const currentPrice = prices[prices.length - 1];
    const priceCondition = currentPrice >= (sixMonthLow * 1.40);

    // RSI above 70
    const rsiCondition = rsi > 70;

    // Acceleration visible (positive)
    const accelerationCondition = acceleration > 0;

    // Media tone shifts from strong to transformative
    const mediaCondition = marketState.mediaTone === 'Transformative';

    return {
        active: priceCondition && rsiCondition && accelerationCondition && mediaCondition,
        details: {
            priceFromLow: ((currentPrice - sixMonthLow) / sixMonthLow * 100).toFixed(1) + '%',
            rsi: rsi.toFixed(1),
            acceleration: acceleration.toFixed(2),
            mediaTone: marketState.mediaTone
        }
    };
};

// 2. Asset Specific Rules

const checkNVDASMCIRules = (prices, rsi, volumes) => {
    const signals = { trim1: false, trim2: false, finalExit: false, reasons: [] };
    const currentPrice = prices[prices.length - 1];

    // TRIM 1: Sell 30%
    let t1Count = 0;
    if (rsi >= 82) { t1Count++; signals.reasons.push('RSI ≥ 82'); }

    // +35% in < 15 trading days
    const price15DaysAgo = prices[prices.length - 16];
    if (price15DaysAgo && (currentPrice - price15DaysAgo) / price15DaysAgo >= 0.35) {
        t1Count++;
        signals.reasons.push('+35% in < 15 days');
    }

    // Large parabolic candle (simplified as > 5% daily gain) or gap fade (hard to detect without OHLC, assuming close < open not avail in simple array)
    // We'll use > 8% daily move as proxy for "Large parabolic candle"
    const dailyChange = (currentPrice - prices[prices.length - 2]) / prices[prices.length - 2];
    if (dailyChange > 0.08) {
        t1Count++;
        signals.reasons.push('Parabolic move (>8%)');
    }

    if (t1Count >= 2) signals.trim1 = true;

    // TRIM 2: Sell 30%
    let t2Count = 0;
    // Failed breakout (Lower high after high? Simplified: Price < 5 day high)
    const fiveDayHigh = Math.max(...prices.slice(-5));
    if (currentPrice < fiveDayHigh * 0.98) { // 2% below recent high
        t2Count++;
        signals.reasons.push('Failed breakout / Pullback');
    }

    // Large volume spike but weak net gain (High vol, low change)
    // Needs volume data. Assuming we have it.
    const recentVol = volumes[volumes.length - 1];
    const avgVol = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
    if (recentVol > avgVol * 2 && dailyChange < 0.01) {
        t2Count++;
        signals.reasons.push('Churn (High Vol, Low Gain)');
    }

    if (t2Count >= 2) signals.trim2 = true;

    // FINAL EXIT: Sell 40%
    let feCount = 0;
    // Close below 10 day MA
    const sma10 = calculateSMA(prices, 10);
    if (currentPrice < sma10) {
        feCount++;
        signals.reasons.push('Below 10d MA');
    }

    // Momentum stall > 3 sessions (Price flat/down for 3 days)
    const p3 = prices[prices.length - 1];
    const p2 = prices[prices.length - 2];
    const p1 = prices[prices.length - 3];
    if (p3 <= p2 && p2 <= p1) {
        feCount++;
        signals.reasons.push('Momentum Stall (3 days)');
    }

    if (feCount >= 2) signals.finalExit = true;

    return signals;
};

const checkBTCRules = (prices, rsi) => {
    const signals = { trim1: false, trim2: false, finalExit: false, reasons: [] };
    const currentPrice = prices[prices.length - 1];

    // TRIM 1
    let t1Count = 0;
    if (rsi >= 80) { t1Count++; signals.reasons.push('RSI ≥ 80'); }
    if (marketState.fearGreedIndex > 90) { t1Count++; signals.reasons.push('Fear/Greed > 90'); }
    // Mainstream coverage hyper bullish (Proxy: Media Tone)
    if (marketState.mediaTone === 'Transformative' || marketState.mediaTone === 'Strong') {
        t1Count++;
        signals.reasons.push('Hyper Bullish Media');
    }
    if (t1Count >= 2) signals.trim1 = true;

    // TRIM 2
    let t2Count = 0;
    // Rejection wick > 4% (Hard with just close, using daily drop > 4%)
    const dailyDrop = (prices[prices.length - 2] - currentPrice) / prices[prices.length - 2];
    if (dailyDrop > 0.04) { t2Count++; signals.reasons.push('Large Drop (>4%)'); }
    if (marketState.btcFundingRates === 'Spike') { t2Count++; signals.reasons.push('Funding Rate Spike'); }
    if (marketState.btcSocialVolume === 'Explodes') { t2Count++; signals.reasons.push('Social Vol Explosion'); }
    if (t2Count >= 2) signals.trim2 = true;

    // FINAL EXIT
    let feCount = 0;
    // Close below 21 day MA
    const sma21 = calculateSMA(prices, 21);
    if (currentPrice < sma21) { feCount++; signals.reasons.push('Below 21d MA'); }
    // Narrative shift (Proxy: Media Tone)
    if (marketState.mediaTone === 'Uncertain') { feCount++; signals.reasons.push('Narrative Doubt'); }

    if (feCount >= 2) signals.finalExit = true;

    return signals;
};

const checkMETARules = (prices, rsi) => {
    const signals = { trim1: false, trim2: false, finalExit: false, reasons: [] };
    const currentPrice = prices[prices.length - 1];

    // TRIM 1
    let t1Count = 0;
    if (rsi >= 78) { t1Count++; signals.reasons.push('RSI ≥ 78'); }
    // +25% in < 20 days
    const price20DaysAgo = prices[prices.length - 21];
    if (price20DaysAgo && (currentPrice - price20DaysAgo) / price20DaysAgo >= 0.25) {
        t1Count++;
        signals.reasons.push('+25% in < 20 days');
    }
    // Headlines dominant (Proxy: Media Tone)
    if (marketState.mediaTone === 'Transformative') { t1Count++; signals.reasons.push('Dominant Headlines'); }
    if (t1Count >= 2) signals.trim1 = true;

    // TRIM 2
    let t2Count = 0;
    // RSI Divergence
    const rsiSeries = calculateRSI(prices); // Re-calc full series
    if (detectRSIDivergence(prices, rsiSeries)) { t2Count++; signals.reasons.push('RSI Divergence'); }
    // Failed breakout (Price < 5 day high)
    const fiveDayHigh = Math.max(...prices.slice(-5));
    if (currentPrice < fiveDayHigh * 0.98) { t2Count++; signals.reasons.push('Failed Breakout'); }
    if (t2Count >= 2) signals.trim2 = true;

    // FINAL EXIT
    let feCount = 0;
    // Close below 20 day MA
    const sma20 = calculateSMA(prices, 20);
    if (currentPrice < sma20) { feCount++; signals.reasons.push('Below 20d MA'); }
    // Media overextended
    if (marketState.mediaTone === 'Overextended') { feCount++; signals.reasons.push('Media Overextended'); }
    if (feCount >= 2) signals.finalExit = true;

    return signals;
};

const checkMSFTGOOGRules = (prices, rsi) => {
    const signals = { trim1: false, trim2: false, finalExit: false, reasons: [] };
    const currentPrice = prices[prices.length - 1];

    // TRIM 1
    let t1Count = 0;
    if (rsi >= 75) { t1Count++; signals.reasons.push('RSI ≥ 75'); }
    // +18% in 30 days
    const price30DaysAgo = prices[prices.length - 31];
    if (price30DaysAgo && (currentPrice - price30DaysAgo) / price30DaysAgo >= 0.18) {
        t1Count++;
        signals.reasons.push('+18% in 30 days');
    }
    if (t1Count >= 2) signals.trim1 = true;

    // TRIM 2
    let t2Count = 0;
    // Momentum Divergence (RSI Divergence proxy)
    const rsiSeries = calculateRSI(prices);
    if (detectRSIDivergence(prices, rsiSeries)) { t2Count++; signals.reasons.push('Momentum Divergence'); }
    // Sideways churn (Low volatility for 5 days after run? Simplified: ATR drop)
    // Using simple price range check
    const last5 = prices.slice(-5);
    const range = (Math.max(...last5) - Math.min(...last5)) / Math.min(...last5);
    if (range < 0.02) { t2Count++; signals.reasons.push('Sideways Churn'); }
    if (t2Count >= 2) signals.trim2 = true;

    // FINAL EXIT
    let feCount = 0;
    // Break of 50 day MA
    const sma50 = calculateSMA(prices, 50);
    if (currentPrice < sma50) { feCount++; signals.reasons.push('Below 50d MA'); }
    // Analyst concerns
    if (marketState.analystCommentary === 'Valuation Concerns') { feCount++; signals.reasons.push('Analyst Concerns'); }
    if (feCount >= 2) signals.finalExit = true;

    return signals;
};

const getMeltupSignal = (symbol, prices, volumes) => {
    if (!prices || prices.length < 130) return { signal: 'INSUFFICIENT DATA', reasons: [] };

    const currentPrice = prices[prices.length - 1];
    const rsiSeries = calculateRSI(prices);
    const rsi = rsiSeries[rsiSeries.length - 1];
    const acceleration = calculateAcceleration(prices);

    // 1. Check System Activation
    const activation = checkSystemActivation(prices, rsi, acceleration);

    if (!activation.active) {
        return {
            signal: 'MONITORING',
            reasons: ['System not active'],
            details: activation.details
        };
    }

    // 2. Apply Asset Specific Rules
    let result = { trim1: false, trim2: false, finalExit: false, reasons: [] };

    if (symbol === 'NVDA' || symbol === 'SMCI') {
        result = checkNVDASMCIRules(prices, rsi, volumes);
    } else if (symbol === 'BTC-USD') {
        result = checkBTCRules(prices, rsi);
    } else if (symbol === 'META') {
        result = checkMETARules(prices, rsi);
    } else if (symbol === 'MSFT' || symbol === 'GOOG') {
        result = checkMSFTGOOGRules(prices, rsi);
    }

    // Determine highest priority signal
    if (result.finalExit) return { signal: 'FINAL EXIT', reasons: result.reasons, details: activation.details };
    if (result.trim2) return { signal: 'TRIM 2', reasons: result.reasons, details: activation.details };
    if (result.trim1) return { signal: 'TRIM 1', reasons: result.reasons, details: activation.details };

    return { signal: 'HOLD (EUPHORIA)', reasons: ['System Active', 'No Exit Triggers'], details: activation.details };
};

// Calculate Pivot Points (S1, S2, S3)
const calculatePivotPoints = (high, low, close) => {
    const pivot = (high + low + close) / 3;
    const s1 = (2 * pivot) - high;
    const s2 = pivot - (high - low);
    const s3 = low - 2 * (high - pivot);
    const r1 = (2 * pivot) - low;
    const r2 = pivot + (high - low);
    const r3 = high + 2 * (pivot - low);

    return { pivot, s1, s2, s3, r1, r2, r3 };
};

// Find Swing Lows (Local Minima)
const findSwingLows = (prices, volumes = [], period = 20) => {
    if (!prices || prices.length < period) return [];

    const swingLows = [];

    // Look for local minima (lookback of 5 days on each side)
    for (let i = 5; i < prices.length - 5; i++) {
        let isLow = true;
        const currentPrice = prices[i];

        // Check if it's lower than neighbors
        for (let j = 1; j <= 5; j++) {
            if (prices[i - j] <= currentPrice || prices[i + j] <= currentPrice) {
                isLow = false;
                break;
            }
        }

        if (isLow) {
            swingLows.push({
                price: currentPrice,
                index: i,
                volume: volumes[i] || 0,
                type: 'swing_low'
            });
        }
    }

    // Return most recent swing lows
    return swingLows.slice(-period);
};

// Calculate Volume-Weighted Price Levels
const calculateVolumeWeightedLevels = (prices, volumes, bins = 20) => {
    if (!prices || !volumes || prices.length < 50) return [];

    // Create price histogram weighted by volume
    const min = Math.min(...prices);
    const max = Math.max(...prices);
    const binSize = (max - min) / bins;

    const histogram = new Array(bins).fill(0).map(() => ({
        priceLevel: 0,
        volume: 0,
        count: 0
    }));

    // Fill histogram
    for (let i = 0; i < prices.length; i++) {
        const binIndex = Math.min(Math.floor((prices[i] - min) / binSize), bins - 1);
        histogram[binIndex].volume += volumes[i] || 0;
        histogram[binIndex].priceLevel += prices[i];
        histogram[binIndex].count++;
    }

    // Calculate average price for each bin
    histogram.forEach(bin => {
        if (bin.count > 0) {
            bin.priceLevel = bin.priceLevel / bin.count;
        }
    });

    // Sort by volume and return top levels
    const sorted = histogram
        .filter(bin => bin.count > 0)
        .sort((a, b) => b.volume - a.volume);

    return sorted.slice(0, 5).map(bin => ({
        price: bin.priceLevel,
        volume: bin.volume,
        type: 'volume_profile'
    }));
};

// Calculate Fibonacci Retracement Levels
const calculateFibonacciLevels = (prices) => {
    if (!prices || prices.length < 60) return [];

    // Use last 6 months of data to find swing high/low
    const recentPrices = prices.slice(-120); // ~6 months
    const high = Math.max(...recentPrices);
    const low = Math.min(...recentPrices);
    const range = high - low;

    const fibRatios = [0.236, 0.382, 0.5, 0.618, 0.786];

    return fibRatios.map(ratio => ({
        price: high - (range * ratio),
        ratio: ratio,
        type: 'fibonacci'
    }));
};

// Get Key Moving Average Levels
const calculateKeyMovingAverages = (prices) => {
    if (!prices || prices.length < 200) return [];

    const levels = [];

    // 50-day MA
    if (prices.length >= 50) {
        const sma50 = calculateSMA(prices, 50);
        if (sma50) {
            levels.push({ price: sma50, period: 50, type: 'moving_average' });
        }
    }

    // 100-day MA
    if (prices.length >= 100) {
        const sma100 = calculateSMA(prices, 100);
        if (sma100) {
            levels.push({ price: sma100, period: 100, type: 'moving_average' });
        }
    }

    // 200-day MA
    const sma200 = calculateSMA(prices, 200);
    if (sma200) {
        levels.push({ price: sma200, period: 200, type: 'moving_average' });
    }

    return levels;
};

// MASTER FUNCTION: Detect Support/Resistance Levels
const detectSupportResistanceLevels = (prices, volumes, currentPrice) => {
    if (!prices || prices.length < 60) return [];

    const allLevels = [];

    // 1. Pivot Points (using last 20 days)
    const recentPrices = prices.slice(-20);
    const high = Math.max(...recentPrices);
    const low = Math.min(...recentPrices);
    const close = prices[prices.length - 1];
    const pivots = calculatePivotPoints(high, low, close);

    if (pivots.s1 < currentPrice) {
        allLevels.push({ price: pivots.s1, type: 'pivot_s1', strength: 0, touches: 0, description: 'Pivot Support S1' });
    }
    if (pivots.s2 < currentPrice) {
        allLevels.push({ price: pivots.s2, type: 'pivot_s2', strength: 0, touches: 0, description: 'Pivot Support S2' });
    }
    if (pivots.s3 < currentPrice) {
        allLevels.push({ price: pivots.s3, type: 'pivot_s3', strength: 0, touches: 0, description: 'Pivot Support S3' });
    }

    // 2. Swing Lows
    const swingLows = findSwingLows(prices, volumes);
    swingLows.forEach((swing, idx) => {
        if (swing.price < currentPrice) {
            allLevels.push({
                price: swing.price,
                type: 'swing_low',
                strength: 0,
                touches: 0,
                description: `Previous swing low (#${swingLows.length - idx})`
            });
        }
    });

    // 3. Volume-Weighted Levels
    const volumeLevels = calculateVolumeWeightedLevels(prices, volumes);
    volumeLevels.forEach(level => {
        if (level.price < currentPrice) {
            allLevels.push({
                price: level.price,
                type: 'volume_profile',
                strength: 0,
                touches: 0,
                description: 'High volume zone'
            });
        }
    });

    // 4. Fibonacci Retracements
    const fibLevels = calculateFibonacciLevels(prices);
    fibLevels.forEach(fib => {
        if (fib.price < currentPrice) {
            allLevels.push({
                price: fib.price,
                type: 'fibonacci',
                strength: 0,
                touches: 0,
                description: `Fib ${(fib.ratio * 100).toFixed(1)}% retracement`
            });
        }
    });

    // 5. Moving Averages
    const maLevels = calculateKeyMovingAverages(prices);
    maLevels.forEach(ma => {
        if (ma.price < currentPrice) {
            allLevels.push({
                price: ma.price,
                type: 'moving_average',
                strength: 0,
                touches: 0,
                description: `${ma.period}-day MA support`
            });
        }
    });

    // Merge similar price levels (within 1% of each other)
    const mergedLevels = [];
    const tolerance = currentPrice * 0.01; // 1% tolerance

    allLevels.forEach(level => {
        const existing = mergedLevels.find(m => Math.abs(m.price - level.price) < tolerance);
        if (existing) {
            // Increase strength for confluent levels
            existing.strength += 2;
            existing.touches += 1;
            existing.description += ` + ${level.description}`;
            // Use average price
            existing.price = (existing.price + level.price) / 2;
        } else {
            mergedLevels.push({ ...level, strength: 2, touches: 1 });
        }
    });

    // Calculate allocation percentage based on distance and strength
    mergedLevels.forEach((level, idx) => {
        const dropPercent = ((currentPrice - level.price) / currentPrice) * 100;
        const strengthBonus = Math.min(level.strength, 10);

        // Base allocation on depth of drop
        let baseAlloc = 0;
        if (dropPercent >= 25) baseAlloc = 30;
        else if (dropPercent >= 20) baseAlloc = 25;
        else if (dropPercent >= 15) baseAlloc = 20;
        else if (dropPercent >= 10) baseAlloc = 15;
        else if (dropPercent >= 5) baseAlloc = 10;
        else baseAlloc = 5;

        // Adjust for strength
        level.allocation = Math.min(baseAlloc + strengthBonus, 40);
        level.dropPercent = dropPercent;
    });

    // Sort by price (highest first, since we're showing support below current price)
    mergedLevels.sort((a, b) => b.price - a.price);

    // Return top 7 levels only
    return mergedLevels.slice(0, 7);
};

// ===== DATA MANAGER & PERFORMANCE =====

class DataManager {
    constructor() {
        this.cache = {};
        this.CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
        this.STALE_DURATION = 60 * 1000; // 1 minute (refresh in background if older)
        this.loadFromStorage();
    }

    loadFromStorage() {
        try {
            const stored = localStorage.getItem('stockDataCache');
            if (stored) {
                this.cache = JSON.parse(stored);
            }
        } catch (e) {
            console.error("Failed to load cache", e);
        }
    }

    saveToStorage() {
        try {
            localStorage.setItem('stockDataCache', JSON.stringify(this.cache));
        } catch (e) {
            console.error("Failed to save cache", e);
        }
    }

    async fetchWithRetry(url, retries = 3, backoff = 500) {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (err) {
                if (i === retries - 1) throw err;
                await new Promise(r => setTimeout(r, backoff * Math.pow(2, i)));
            }
        }
    }

    async getStockData(symbol, range = '1mo', interval = '1d') {
        const key = `${symbol}-${range}-${interval}`;
        const now = Date.now();
        const cached = this.cache[key];

        // 1. Return cached data immediately if available
        if (cached) {
            // If fresh enough, just return it
            if (now - cached.timestamp < this.STALE_DURATION) {
                console.log(`[Cache] Hit for ${key}`);
                return { data: cached.data, source: 'cache' };
            }
            // If stale but valid, return it and fetch in background
            console.log(`[Cache] Stale hit for ${key}. Fetching background...`);
            this.fetchAndCache(symbol, range, interval).then(newData => {
                if (newData) {
                    // Dispatch event to update UI if user is still viewing this
                    document.dispatchEvent(new CustomEvent('dataUpdated', { detail: { symbol, key } }));
                }
            });
            return { data: cached.data, source: 'stale' };
        }

        // 2. No cache, fetch fresh
        console.log(`[Cache] Miss for ${key}`);
        const data = await this.fetchAndCache(symbol, range, interval);
        return { data, source: 'network' };
    }

    async fetchAndCache(symbol, range, interval) {
        try {
            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=${interval}&range=${range}`;
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

            const json = await this.fetchWithRetry(proxyUrl);

            if (!json.chart || !json.chart.result || json.chart.result.length === 0) {
                throw new Error('No data found');
            }

            const result = json.chart.result[0];
            const key = `${symbol}-${range}-${interval}`;

            this.cache[key] = {
                timestamp: Date.now(),
                data: result
            };
            this.saveToStorage();
            return result;
        } catch (error) {
            console.error(`Error fetching stock data for ${symbol}:`, error);
            return null;
        }
    }

    // Fetch current quotes for multiple symbols in one request
    async fetchBatchQuotes(symbols) {
        try {
            const symbolsParam = symbols.join(',');
            const url = `https://query1.finance.yahoo.com/v8/finance/spark?symbols=${symbolsParam}&range=1d&interval=1d`;
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

            const json = await this.fetchWithRetry(proxyUrl);

            if (!json) {
                throw new Error('No spark data found');
            }

            // Map Spark response to Quote format
            return Object.values(json).map(data => {
                const currentPrice = data.close && data.close.length > 0 ? data.close[data.close.length - 1] : null;
                const prevClose = data.chartPreviousClose;

                if (!currentPrice || !prevClose) return null;

                const change = ((currentPrice - prevClose) / prevClose) * 100;

                return {
                    symbol: data.symbol,
                    regularMarketPrice: currentPrice,
                    regularMarketChangePercent: change,
                    regularMarketVolume: 0 // Volume not available in simple spark
                };
            }).filter(item => item !== null);

        } catch (error) {
            console.error('Error fetching batch quotes:', error);
            return [];
        }
    }

    // Clear cache for a specific symbol to force refresh
    invalidate(symbol) {
        Object.keys(this.cache).forEach(key => {
            if (key.startsWith(symbol)) delete this.cache[key];
        });
        this.saveToStorage();
    }
}

const dataManager = new DataManager();

// Fetch Stock Data (Wrapper using DataManager)
const fetchStockData = async (symbol, range = '1mo', interval = '1d') => {
    const result = await dataManager.getStockData(symbol, range, interval);
    return result ? result.data : null;
};

// View Management
const showDashboard = () => {
    elements.detailView.classList.add('hidden');
    elements.dashboardView.classList.remove('hidden');
    initDashboard();
};

const showDetail = (symbol) => {
    elements.dashboardView.classList.add('hidden');
    elements.detailView.classList.remove('hidden');
    updateStock(symbol);
};

// Dashboard Logic
const initDashboard = async () => {
    elements.dashboardList.innerHTML = '';

    // 1. Create rows with placeholders immediately
    const rowMap = {};
    for (const symbol of WATCHLIST) {
        const row = document.createElement('tr');
        row.id = `row-${symbol}`;
        row.innerHTML = `
            <td class="ticker-cell">${symbol}</td>
            <td class="price-cell">Loading...</td>
            <td class="change">--</td>
            <td><span class="status-badge neutral">Loading...</span></td>
            <td>--</td>
            <td><span class="status-badge" id="dashSignal-${symbol}">--</span></td>
            <td class="price-cell">--</td>
            <td><button class="action-btn">View</button></td>
        `;
        elements.dashboardList.appendChild(row);
        rowMap[symbol] = row;

        // Add click listener for "View" button
        const viewBtn = row.querySelector('.action-btn');
        if (viewBtn) {
            viewBtn.addEventListener('click', () => showDetail(symbol));
        }
    }

    // 2. Fetch Batch Quotes (Fast)
    console.log("Fetching batch quotes...");
    const quotes = await dataManager.fetchBatchQuotes(WATCHLIST);

    quotes.forEach(quote => {
        const symbol = quote.symbol;
        const row = rowMap[symbol];
        if (!row) return;

        const price = quote.regularMarketPrice;
        const change = quote.regularMarketChangePercent;
        const volume = quote.regularMarketVolume;

        // Update basic info
        row.querySelector('.price-cell').textContent = `$${price.toFixed(2)}`;
        const changeCell = row.querySelector('.change');
        changeCell.textContent = `${change > 0 ? '+' : ''}${change.toFixed(2)}%`;
        changeCell.className = `change ${change >= 0 ? 'positive' : 'negative'}`;
    });

    // 3. Background Fetch for Indicators (Slow)
    console.log("Starting background fetch for indicators...");

    // Process one by one to avoid choking network, but start immediately
    for (const symbol of WATCHLIST) {
        fetchStockData(symbol, '1y', '1d').then(data => {
            if (!data) return;

            const row = rowMap[symbol];
            if (!row) return;

            const meta = data.meta;
            const currentPrice = meta.regularMarketPrice;

            // Indicators
            let rsi = null;
            let sma200 = null;
            let status = 'Neutral';
            let statusClass = 'neutral';

            if (data.indicators.quote[0].close) {
                const quotes = data.indicators.quote[0].close.filter(p => p !== null);
                const rsiSeries = calculateRSI(quotes);
                rsi = rsiSeries ? rsiSeries[rsiSeries.length - 1] : null;
                sma200 = calculateSMA(quotes, 200);
            }

            // Euphoria Logic
            if (rsi && sma200) {
                const extension = ((currentPrice - sma200) / sma200) * 100;
                let euphoriaScore = 0;

                // Adjusted thresholds
                if (rsi > 75) euphoriaScore += 1;
                if (rsi > 85) euphoriaScore += 1;
                if (extension > 30) euphoriaScore += 1;
                if (extension > 50) euphoriaScore += 1;

                if (euphoriaScore >= 3) { status = 'EXTREME GREED'; statusClass = 'sell'; }
                else if (euphoriaScore >= 1) { status = 'Elevated'; statusClass = 'sell'; }
                else if (rsi < 30) { status = 'Fear'; statusClass = 'buy'; }
            }

            // Update Status and RSI
            const statusBadge = row.querySelectorAll('.status-badge')[0];
            statusBadge.textContent = status;
            statusBadge.className = `status-badge ${statusClass}`;

            const rsiCell = row.children[4];
            rsiCell.textContent = rsi ? rsi.toFixed(1) : 'N/A';
            rsiCell.style.color = rsi > 70 ? 'var(--danger)' : (rsi < 30 ? 'var(--success)' : 'inherit');

            // Calculate Support Levels for "Next Buy Level"
            let nextBuyPrice = currentPrice * 0.85; // Default fallback
            let nextBuyAlloc = 15;

            if (data.indicators.quote[0].close) {
                const rawQuotes = data.indicators.quote[0].close;
                const longTermQuotes = rawQuotes.filter(p => p !== null);
                const volumes = data.indicators.quote[0].volume.filter(v => v !== null);

                const levels = detectSupportResistanceLevels(longTermQuotes, volumes, currentPrice);
                if (levels.length > 0) {
                    nextBuyPrice = levels[0].price;
                    nextBuyAlloc = levels[0].allocation;
                }

                // Update Next Buy Level
                const buyCell = row.children[6];
                buyCell.innerHTML = `$${nextBuyPrice.toFixed(2)} <span style="color: var(--success); font-weight: 600;">(${nextBuyAlloc}%)</span>`;

                // Calculate Meltup Signal
                const signal = getMeltupSignal(symbol, longTermQuotes, volumes);
                const signalBadge = row.querySelector(`#dashSignal-${symbol}`);

                if (signalBadge) {
                    signalBadge.textContent = signal.signal;
                    if (signal.signal.includes('TRIM') || signal.signal.includes('EXIT')) {
                        signalBadge.className = 'status-badge sell';
                        signalBadge.style.animation = 'pulse 2s infinite';
                    } else if (signal.signal.includes('HOLD')) {
                        signalBadge.className = 'status-badge warning';
                    } else {
                        signalBadge.className = 'status-badge neutral';
                    }
                }
            }
        });
    }
};

// Initialize Chart
const initChart = () => {
    const ctx = elements.chartCanvas.getContext('2d');

    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
    gradient.addColorStop(0, 'rgba(0, 229, 255, 0.2)');
    gradient.addColorStop(1, 'rgba(0, 229, 255, 0)');

    chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Price',
                    data: [],
                    borderColor: '#00E5FF',
                    backgroundColor: gradient,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    fill: true,
                    tension: 0.1,
                    yAxisID: 'y'
                },
                {
                    label: 'SMA 200',
                    data: [],
                    borderColor: '#FFB300', // Orange
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'y'
                },
                {
                    label: 'RSI (14)',
                    data: [],
                    borderColor: '#7B61FF', // Purple
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'y1',
                    hidden: false // Show by default now
                },
                {
                    type: 'bar',
                    label: 'Volume',
                    data: [],
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    yAxisID: 'y2',
                    barThickness: 'flex'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#8b9bb4', font: { size: 10 } }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(10, 11, 14, 0.9)',
                    titleColor: '#8b9bb4',
                    bodyColor: '#fff',
                    borderColor: 'rgba(255,255,255,0.1)',
                    borderWidth: 1,
                    padding: 12
                }
            },
            scales: {
                x: {
                    grid: { display: false },
                    ticks: { color: '#8b9bb4', maxTicksLimit: 8 }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    grid: { color: 'rgba(255,255,255,0.05)' },
                    ticks: { color: '#8b9bb4' }
                },
                y1: { // RSI Axis
                    type: 'linear',
                    display: true, // Show axis
                    position: 'left',
                    min: 0,
                    max: 100,
                    grid: { display: false },
                    ticks: { color: '#7B61FF', stepSize: 30 }
                },
                y2: { // Volume Axis
                    type: 'linear',
                    display: false,
                    position: 'left',
                    grid: { display: false },
                    beginAtZero: true
                }
            },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            }
        }
    });
};


// Helper: Get Cached Price or Fetch from Spark API
const getCachedPriceOrFetch = async (symbol) => {
    // Check if we have recent Spark data from dashboard batch fetch
    const batchKey = `spark-batch-${Date.now()}`;

    // Try to fetch single symbol from Spark API
    try {
        const url = `https://query1.finance.yahoo.com/v8/finance/spark?symbols=${symbol}&range=1d&interval=1d`;
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

        const json = await dataManager.fetchWithRetry(proxyUrl, 2, 300); // Faster retry for quick fetch

        if (json && json[symbol]) {
            const data = json[symbol];
            const currentPrice = data.close && data.close.length > 0 ? data.close[data.close.length - 1] : null;
            const prevClose = data.chartPreviousClose;

            if (currentPrice && prevClose) {
                const change = ((currentPrice - prevClose) / prevClose) * 100;
                return {
                    symbol: symbol,
                    price: currentPrice,
                    change: change,
                    prevClose: prevClose
                };
            }
        }
    } catch (error) {
        console.warn('Quick price fetch failed, will load from full data:', error);
    }

    return null;
};

// Update Detail View
const updateStock = async (symbol, range = '1mo', interval = '1d') => {
    // Update state immediately
    const isNewSymbol = currentStock.symbol !== symbol;
    currentStock.symbol = symbol;

    // PHASE 1: INSTANT PRICE DISPLAY (if possible)
    if (isNewSymbol) {
        // Reset UI to loading state
        elements.ticker.textContent = symbol.toUpperCase();
        elements.price.textContent = 'Loading...';
        elements.change.textContent = '--';
        elements.levelsList.innerHTML = `<tr><td colspan="4" style="text-align:center; padding: 20px;">Loading data...</td></tr>`;
        elements.rsi.textContent = '--';
        elements.maExtension.textContent = '--';
        elements.topSignalValue.textContent = '--';
        elements.topSignalStatus.textContent = '--';
        elements.volume.textContent = '--';

        // Try to get quick price from Spark API
        console.log(`[Phase 1] Fetching quick price for ${symbol}...`);
        const quickPrice = await getCachedPriceOrFetch(symbol);

        if (quickPrice) {
            console.log(`[Phase 1] ✓ Quick price loaded`);
            elements.price.textContent = `$${quickPrice.price.toFixed(2)}`;
            elements.change.textContent = `${quickPrice.change > 0 ? '+' : ''}${quickPrice.change.toFixed(2)}%`;
            elements.change.className = `change ${quickPrice.change >= 0 ? 'positive' : 'negative'}`;
            currentStock.price = quickPrice.price;
        }
    }

    // PHASE 2 & 3: PARALLEL FETCH (Chart + Indicators)
    console.log(`[Phase 2/3] Fetching chart (${range}) and indicator (1y) data in parallel...`);

    Promise.all([
        fetchStockData(symbol, range, interval),  // For chart
        fetchStockData(symbol, '1y', '1d')        // For indicators
    ]).then(([chartData, indicatorData]) => {
        // Only update if we're still viewing the same symbol
        if (currentStock.symbol !== symbol) {
            console.log(`Symbol changed, ignoring data for ${symbol}`);
            return;
        }

        // PHASE 2: UPDATE CHART
        if (chartData) {
            console.log(`[Phase 2] ✓ Chart data loaded`);
            const meta = chartData.meta;
            const quotes = chartData.indicators.quote[0];
            const timestamps = chartData.timestamp;

            // Filter out null values
            const cleanData = timestamps.map((t, i) => ({
                x: new Date(t * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric' }),
                y: quotes.close[i]
            })).filter(d => d.y !== null);

            const currentPrice = meta.regularMarketPrice;

            // Calculate change
            let prevClose = meta.previousClose;
            if (!prevClose && quotes.close) {
                const validQuotes = quotes.close.filter(p => p !== null);
                if (validQuotes.length >= 2) {
                    prevClose = validQuotes[validQuotes.length - 2];
                }
            }
            if (!prevClose) prevClose = meta.chartPreviousClose;

            const changePercent = ((currentPrice - prevClose) / prevClose) * 100;

            // Update state and header
            currentStock.price = currentPrice;
            currentStock.data = cleanData;
            currentStock.meta = meta;

            elements.ticker.textContent = symbol.toUpperCase();
            elements.price.textContent = `$${currentPrice.toFixed(2)}`;
            elements.change.textContent = `${changePercent > 0 ? '+' : ''}${changePercent.toFixed(2)}%`;
            elements.change.className = `change ${changePercent >= 0 ? 'positive' : 'negative'}`;

            // Update Chart
            chartInstance.data.labels = cleanData.map(d => d.x);
            chartInstance.data.datasets[0].data = cleanData.map(d => d.y);

            // Calculate RSI for chart
            const chartQuotes = cleanData.map(d => d.y);
            const rsiSeries = calculateRSI(chartQuotes);
            chartInstance.data.datasets[2].data = rsiSeries || [];

            // Plot Volume
            const chartVolumes = quotes.volume.filter((v, i) => timestamps[i] !== null);
            chartInstance.data.datasets[3].data = chartVolumes;

            // Plot SMA 200 if data is sufficient
            if (range === '1y' || chartQuotes.length > 200) {
                const smaSeries = calculateSMASeries(chartQuotes, 200);
                chartInstance.data.datasets[1].data = smaSeries;
            } else {
                chartInstance.data.datasets[1].data = [];
            }

            chartInstance.update();

            // Update volume
            const vol = meta.regularMarketVolume;
            elements.volume.textContent = vol ? `${(vol / 1000000).toFixed(1)}M` : '--';
        }

        // PHASE 3: UPDATE INDICATORS
        if (indicatorData && indicatorData.indicators.quote[0].close) {
            console.log(`[Phase 3] ✓ Indicator data loaded`);
            const rawQuotes = indicatorData.indicators.quote[0].close;
            const longTermQuotes = rawQuotes.filter(p => p !== null);
            const volumes = indicatorData.indicators.quote[0].volume.filter(v => v !== null);
            const currentPrice = currentStock.price || indicatorData.meta.regularMarketPrice;

            // RSI (Last Value)
            const rsiSeriesLong = calculateRSI(longTermQuotes);
            const rsi = rsiSeriesLong ? rsiSeriesLong[rsiSeriesLong.length - 1] : null;
            elements.rsi.textContent = rsi ? rsi.toFixed(1) : 'N/A';

            // SMA 200 (Last Value)
            const sma200 = calculateSMA(longTermQuotes, 200);

            // Top Signal Score System (0-10 scale)
            if (rsi && sma200) {
                const extension = ((currentPrice - sma200) / sma200) * 100;
                elements.maExtension.textContent = `${extension > 0 ? '+' : ''}${extension.toFixed(1)}%`;

                let topSignalScore = 0;

                // 1. RSI Divergence (+3 points)
                const hasDivergence = detectRSIDivergence(longTermQuotes, rsiSeriesLong);
                if (hasDivergence) topSignalScore += 3;

                // 2. Volume Distribution (+2 points)
                const volumes = indicatorData.indicators.quote[0].volume.filter(v => v !== null);
                const hasDistribution = detectDistributionVolume(longTermQuotes, volumes);
                if (hasDistribution) topSignalScore += 2;

                // 3. Extension Threshold (+2 points max)
                if (extension > 30) topSignalScore += 2;
                else if (extension > 20) topSignalScore += 1;

                // 4. RSI Extremes (+3 points max)
                if (rsi > 85) topSignalScore += 3;
                else if (rsi > 75) topSignalScore += 2;
                else if (rsi > 70) topSignalScore += 1;

                // Interpret Score
                let status = '';
                let statusDesc = '';

                if (topSignalScore >= 7) {
                    status = `${topSignalScore}/10 CRITICAL`;
                    statusDesc = 'Top Signal';
                } else if (topSignalScore >= 4) {
                    status = `${topSignalScore}/10 WARNING`;
                    statusDesc = 'Caution Zone';
                } else if (rsi < 30) {
                    status = `${topSignalScore}/10 OPPORTUNITY`;
                    statusDesc = 'Oversold';
                } else {
                    status = `${topSignalScore}/10`;
                    statusDesc = 'Melt-Up Mode';
                }

                elements.topSignalValue.textContent = status;

                // Detect Market Phase (replaces simple status description)
                const marketPhase = detectMarketPhase(longTermQuotes, rsi, extension, topSignalScore, 0, volumes); // We'll calculate buyQuality next
                elements.topSignalStatus.textContent = marketPhase;

                // --- BUY QUALITY SCORE (Inverse Logic) ---
                let buyQualityScore = 0;

                // 1. Bullish RSI Divergence (+3 points)
                const hasBullishDivergence = detectBullishRSIDivergence(longTermQuotes, rsiSeriesLong);
                if (hasBullishDivergence) buyQualityScore += 3;

                // 2. Accumulation Volume (+2 points)
                const hasAccumulation = detectAccumulationVolume(longTermQuotes, volumes);
                if (hasAccumulation) buyQualityScore += 2;

                // 3. Deep Value vs 200MA (+2 points)
                if (extension < -20) buyQualityScore += 2;
                else if (extension < -10) buyQualityScore += 1;

                // 4. RSI Oversold (+3 points)
                if (rsi < 20) buyQualityScore += 3;
                else if (rsi < 30) buyQualityScore += 2;
                else if (rsi < 40) buyQualityScore += 1;

                // Interpret Buy Quality Score
                let buyStatus = '';
                let buyDesc = '';

                if (buyQualityScore >= 8) {
                    buyStatus = `${buyQualityScore}/10 🎯`;
                    buyDesc = 'BEST DEAL EVER';
                } else if (buyQualityScore >= 5) {
                    buyStatus = `${buyQualityScore}/10 ✅`;
                    buyDesc = 'Good Deal';
                } else if (buyQualityScore >= 2) {
                    buyStatus = `${buyQualityScore}/10 🤷`;
                    buyDesc = "It's OK";
                } else {
                    buyStatus = `${buyQualityScore}/10 🚫`;
                    buyDesc = "Don't Buy";
                }

                elements.buyQualityValue.textContent = buyStatus;
                elements.buyQualityStatus.textContent = buyDesc;

                // Re-calculate Market Phase with actual buyQualityScore
                const finalMarketPhase = detectMarketPhase(longTermQuotes, rsi, extension, topSignalScore, buyQualityScore, volumes);
                elements.topSignalStatus.textContent = finalMarketPhase;

                // --- COLOR CODING & ALERTS ---

                // Reset classes
                elements.rsi.className = 'value';
                elements.maExtension.className = 'value';
                elements.volume.className = 'value';
                elements.topSignalValue.className = 'value';
                elements.buyQualityValue.className = 'value';

                const rsiDesc = document.getElementById('rsiDesc');
                const maDesc = document.getElementById('maDesc');
                const volDesc = document.getElementById('volDesc');
                const summaryText = document.getElementById('trendSummaryText');
                const summaryBox = document.getElementById('trendSummaryBox');

                // RSI Logic
                if (rsi > 70) {
                    elements.rsi.classList.add('text-danger');
                    rsiDesc.textContent = "Overbought";
                    rsiDesc.style.color = "var(--danger)";
                } else if (rsi > 50) {
                    elements.rsi.classList.add('text-warning');
                    rsiDesc.textContent = "Strong";
                    rsiDesc.style.color = "#FFB300";
                } else if (rsi < 30) {
                    elements.rsi.classList.add('text-success');
                    rsiDesc.textContent = "Oversold";
                    rsiDesc.style.color = "var(--success)";
                } else {
                    rsiDesc.textContent = "Neutral";
                    rsiDesc.style.color = "var(--text-muted)";
                }

                // MA Extension Logic
                if (extension > 20) {
                    elements.maExtension.classList.add('text-danger');
                    maDesc.textContent = "Overextended";
                    maDesc.style.color = "var(--danger)";
                } else if (extension > 10) {
                    elements.maExtension.classList.add('text-warning');
                    maDesc.textContent = "Extended";
                    maDesc.style.color = "#FFB300";
                } else if (extension < -10) {
                    elements.maExtension.classList.add('text-success');
                    maDesc.textContent = "Undervalued";
                    maDesc.style.color = "var(--success)";
                } else {
                    maDesc.textContent = "Fair Value";
                    maDesc.style.color = "var(--text-muted)";
                }

                // Volume Logic (Simple approximation since we don't have avg volume easily accessible without calc)
                // We'll just use a placeholder for now or compare to previous days if possible.
                // For now, let's just label it "Active" if it's high? 
                // Better: Just leave it neutral unless we calculate RVOL.
                volDesc.textContent = "Daily Volume";


                // Euphoria Status Colors & TOP SIGNAL
                const marketStatusBox = document.getElementById('marketStatus');
                let summary = "";

                // Color code Buy Quality Score
                if (buyQualityScore >= 8) {
                    elements.buyQualityValue.classList.add('text-success');
                } else if (buyQualityScore >= 5) {
                    elements.buyQualityValue.classList.add('text-success');
                } else if (buyQualityScore >= 2) {
                    elements.buyQualityValue.classList.add('text-neutral');
                } else {
                    elements.buyQualityValue.classList.add('text-danger');
                }

                if (topSignalScore >= 7) { // TOP SIGNAL
                    elements.topSignalValue.classList.add('text-danger');
                    // Show TOP SIGNAL
                    marketStatusBox.innerHTML = `
                        <div style="color: var(--danger); font-weight: bold; display: flex; align-items: center; gap: 8px;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                            TOP SIGNAL DETECTED - Exit Immediately
                        </div>
                    `;
                    marketStatusBox.style.borderColor = 'var(--danger)';
                    marketStatusBox.style.background = 'rgba(255, 75, 75, 0.1)';

                    let factors = [];
                    if (hasDivergence) factors.push("RSI divergence");
                    if (hasDistribution) factors.push("distribution volume");
                    if (extension > 30) factors.push(`extreme overextension (+${extension.toFixed(0)}%)`);
                    if (rsi > 85) factors.push(`RSI exhaustion (${rsi.toFixed(0)})`);

                    summary = `<strong>🚨 Market Top Detected:</strong> Multiple top signals converging: ${factors.join(', ')}. This is a high-probability reversal zone. <strong>Do NOT buy.</strong> Exit positions or set tight stops.`;

                } else if (buyQualityScore >= 8) { // BEST DEAL EVER
                    elements.topSignalValue.classList.add('text-neutral');
                    marketStatusBox.innerHTML = `<p style="color: var(--success); font-weight: bold;">🎯 BEST DEAL EVER - Generational Opportunity</p>`;
                    marketStatusBox.style.borderColor = 'var(--success)';
                    marketStatusBox.style.background = 'rgba(0, 255, 163, 0.15)';

                    let buyFactors = [];
                    if (hasBullishDivergence) buyFactors.push("bullish divergence");
                    if (hasAccumulation) buyFactors.push("accumulation volume");
                    if (extension < -20) buyFactors.push(`deep value (${extension.toFixed(0)}% below 200MA)`);
                    if (rsi < 20) buyFactors.push(`extreme oversold (RSI ${rsi.toFixed(0)})`);

                    summary = `<strong>🎯 Exceptional Value:</strong> ${buyFactors.join(', ')}. This represents a generational buying opportunity with favorable risk/reward. <strong>Aggressively accumulate on dips.</strong>`;

                } else if (buyQualityScore >= 5) { // GOOD DEAL
                    elements.topSignalValue.classList.add('text-neutral');
                    marketStatusBox.innerHTML = `<p style="color: var(--success);">✅ Good Deal - Favorable Entry</p>`;
                    marketStatusBox.style.borderColor = 'var(--success)';
                    marketStatusBox.style.background = 'rgba(0, 255, 163, 0.08)';

                    summary = `<strong>✅ Good Entry Zone:</strong> RSI is ${rsi < 30 ? 'oversold' : 'pulling back'}, ${extension < -10 ? 'price below 200MA' : 'momentum cooling'}. ${hasAccumulation ? 'Accumulation patterns forming. ' : ''}Risk/reward is favorable. <strong>Consider scaling in.</strong>`;

                } else if (topSignalScore >= 4) { // WARNING ZONE
                    elements.topSignalValue.classList.add('text-warning');
                    marketStatusBox.innerHTML = `<p>⚠️ Warning: Tighten stops</p>`;
                    marketStatusBox.style.borderColor = '#FFB300';
                    marketStatusBox.style.background = 'rgba(255, 179, 0, 0.1)';

                    summary = `<strong>Caution:</strong> Early warning signs detected. ${hasDistribution ? 'Distribution patterns forming. ' : ''}${hasDivergence ? 'RSI divergence emerging. ' : ''}Price is ${extension > 20 ? 'overextended' : 'elevated'}. <strong>Avoid new positions.</strong> Trail stops on existing holdings.`;

                } else if (rsi < 40) { // MILD OPPORTUNITY
                    elements.topSignalValue.classList.add('text-neutral');
                    marketStatusBox.innerHTML = `<p>🤷 ${finalMarketPhase}</p>`;
                    marketStatusBox.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                    marketStatusBox.style.background = 'rgba(255, 255, 255, 0.03)';

                    if (finalMarketPhase === 'ACCUMULATION') {
                        summary = `<strong>Accumulation Phase:</strong> Stock is in a bottoming process. RSI (${rsi.toFixed(0)}) cooling, ${extension < 0 ? 'price below 200MA' : 'momentum settling'}. <strong>Consider limit orders below current price</strong> for better entries.`;
                    } else if (finalMarketPhase === 'DOWNWARD TREND') {
                        summary = `<strong>Downward Trend:</strong> Price is making lower lows. RSI (${rsi.toFixed(0)}), ${extension < 0 ? 'below 200MA' : 'losing momentum'}. <strong>Wait for stabilization</strong> before entering. Look for basing patterns.`;
                    } else {
                        summary = `<strong>Neutral Pullback:</strong> RSI (${rsi.toFixed(0)}) cooling but not deeply oversold. ${extension < 0 ? 'Price below 200MA. ' : ''}No strong signals. <strong>Wait for better setup</strong> or use limit orders.`;
                    }

                } else { // MELT-UP / NEUTRAL / UPWARD TREND
                    elements.topSignalValue.classList.add('text-neutral');
                    marketStatusBox.innerHTML = `<p>📈 ${finalMarketPhase}</p>`;
                    marketStatusBox.style.borderColor = 'rgba(255, 255, 255, 0.05)';
                    marketStatusBox.style.background = 'transparent';

                    if (finalMarketPhase === 'UPWARD TREND') {
                        summary = `<strong>Healthy Uptrend:</strong> Momentum is strong but not overheated. RSI (${rsi.toFixed(0)}) in control. ${extension > 10 ? 'Price extended modestly. ' : ''}Trend is intact. <strong>Hold positions,</strong> set trailing stops, avoid chasing.`;
                    } else if (finalMarketPhase === 'NEUTRAL') {
                        summary = `<strong>Sideways/Neutral:</strong> Stock is consolidating. RSI (${rsi.toFixed(0)}) balanced. No clear direction. Wait for breakout or breakdown confirmation before making decisions.`;
                    } else {
                        summary = `<strong>Trend Intact:</strong> Market phase: ${finalMarketPhase}. ${extension > 10 ? 'Price extended but no divergence yet. ' : ''}<strong>Monitor closely</strong> for warning signs.`;
                    }
                }
                summaryText.innerHTML = summary;

            } else {
                elements.maExtension.textContent = 'N/A';
                elements.topSignalValue.textContent = 'Insufficient Data';
            }
        } catch (e) {
            console.error("Error calculating indicators:", e);
            elements.rsi.textContent = "Err";
        }
    } else {
        console.warn("Invalid indicator data structure", indicatorData);
        elements.rsi.textContent = "N/A";
    }

    // Render Ladder with price/volume data
    if (indicatorData && indicatorData.indicators.quote[0].close) {
        const rawQuotes = indicatorData.indicators.quote[0].close;
        const longTermQuotes = rawQuotes.filter(p => p !== null);
        const volumes = indicatorData.indicators.quote[0].volume.filter(v => v !== null);
        renderLadder(longTermQuotes, volumes);
    } else {
        renderLadder(); // Fallback without data
    }

    // Fetch Analyst Sentiment (in background)
    fetchAnalystSentiment(symbol);

    // Fetch Real-Time Soft Metrics (in background)
    fetchRealTimeData(symbol);

    // Update Meltup Signal Box
    if (indicatorData && indicatorData.indicators.quote[0].close) {
        const rawQuotes = indicatorData.indicators.quote[0].close;
        const longTermQuotes = rawQuotes.filter(p => p !== null);
        const volumes = indicatorData.indicators.quote[0].volume.filter(v => v !== null);

        const signal = getMeltupSignal(symbol, longTermQuotes, volumes);
        const signalBox = document.getElementById('meltupSignalBox');
        const signalStatus = document.getElementById('meltupSignalStatus');
        const signalReasons = document.getElementById('meltupReasons');

        if (signalBox && signalStatus && signalReasons) {
            signalStatus.textContent = signal.signal;

            // Color coding
            if (signal.signal.includes('EXIT') || signal.signal.includes('TRIM')) {
                signalStatus.style.color = 'var(--danger)';
                signalBox.style.borderColor = 'var(--danger)';
                signalBox.style.background = 'rgba(255, 75, 75, 0.1)';
            } else if (signal.signal === 'MONITORING') {
                signalStatus.style.color = 'var(--text-muted)';
                signalBox.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                signalBox.style.background = 'rgba(255, 255, 255, 0.03)';
            } else {
                signalStatus.style.color = 'var(--success)'; // Or neutral/blue for HOLD (EUPHORIA)
                signalBox.style.borderColor = 'var(--primary)';
                signalBox.style.background = 'rgba(0, 229, 255, 0.05)';
            }

            // Reasons
            signalReasons.innerHTML = '';
            if (signal.reasons.length > 0) {
                signal.reasons.forEach(r => {
                    const li = document.createElement('li');
                    li.textContent = `• ${r}`;
                    signalReasons.appendChild(li);
                });
            } else {
                signalReasons.innerHTML = '<li>No active triggers</li>';
            }

            // Add System Activation Details if Monitoring/Active
            if (signal.details) {
                const hr = document.createElement('hr');
                hr.style.borderColor = 'rgba(255,255,255,0.1)';
                hr.style.margin = '8px 0';
                signalReasons.appendChild(hr);

                const details = [
                    `Price vs 6m Low: ${signal.details.priceFromLow}`,
                    `RSI: ${signal.details.rsi}`,
                    `Accel: ${signal.details.acceleration}`,
                    `Media: ${signal.details.mediaTone}`
                ];

                details.forEach(d => {
                    const li = document.createElement('li');
                    li.style.color = '#8b9bb4';
                    li.style.fontSize = '11px';
                    li.textContent = d;
                    signalReasons.appendChild(li);
                });
            }
        }
    }
};

// Initialize Simulation Controls
const initSimulationControls = () => {
    const mediaSelect = document.getElementById('simMediaTone');
    const fearRange = document.getElementById('simFearGreed');
    const fearValue = document.getElementById('simFearGreedValue');
    const fundingSelect = document.getElementById('simFunding');

    if (mediaSelect) {
        mediaSelect.addEventListener('change', (e) => {
            marketState.mediaTone = e.target.value;
            if (currentStock.symbol) updateStock(currentStock.symbol); // Refresh
        });
    }

    if (fearRange) {
        fearRange.addEventListener('input', (e) => {
            marketState.fearGreedIndex = parseInt(e.target.value);
            if (fearValue) fearValue.textContent = e.target.value;
            if (currentStock.symbol) updateStock(currentStock.symbol);
        });
    }

    if (fundingSelect) {
        fundingSelect.addEventListener('change', (e) => {
            marketState.btcFundingRates = e.target.value;
            if (currentStock.symbol) updateStock(currentStock.symbol);
        });
    }
};

// Call initSimulationControls at startup
document.addEventListener('DOMContentLoaded', () => {
    initSimulationControls();
});

// Fetch Analyst Sentiment from Yahoo Finance
const fetchAnalystSentiment = async (symbol) => {
    const analystSummary = document.getElementById('analystSummary');

    try {
        // Use Finnhub API for analyst recommendations (CORS-friendly)
        // Finnhub API Key (Free Tier)
        const apiKey = 'd4j86r1r01queualuh3gd4j86r1r01queualuh40';
        const url = `https://finnhub.io/api/v1/stock/recommendation?symbol=${symbol}&token=${apiKey}`;

        const response = await fetch(url);

        if (!response.ok) {
            throw new Error(`Finnhub API error: ${response.status}`);
        }

        const data = await response.json();

        // Finnhub returns array of monthly recommendations, we want the most recent
        if (data && data.length > 0) {
            const latest = data[0]; // Most recent month

            const strongBuy = latest.strongBuy || 0;
            const buy = latest.buy || 0;
            const hold = latest.hold || 0;
            const sell = latest.sell || 0;
            const strongSell = latest.strongSell || 0;

            const total = strongBuy + buy + hold + sell + strongSell;

            if (total === 0) {
                analystSummary.innerHTML = `<span style="color: #8b9bb4;">No analyst coverage available</span>`;
                return;
            }

            // Calculate overall sentiment
            const bullishScore = (strongBuy * 2 + buy) / total;
            const bearishScore = (strongSell * 2 + sell) / total;

            let sentiment = 'Hold';
            let sentimentColor = '#FFB300';

            if (bullishScore > 1.2) {
                sentiment = 'Strong Buy';
                sentimentColor = '#00E676';
            } else if (bullishScore > 0.6) {
                sentiment = 'Buy';
                sentimentColor = '#4CAF50';
            } else if (bearishScore > 0.6) {
                sentiment = 'Sell';
                sentimentColor = '#FF5252';
            }

            const period = latest.period || 'Current';

            analystSummary.innerHTML = `
                <span style="color: ${sentimentColor}; font-weight: 600;">${sentiment}</span> — 
                ${total} analysts (${period}): <span style="color: #00E676;">${strongBuy} strong buy</span>, 
                <span style="color: #4CAF50;">${buy} buy</span>, 
                <span style="color: #FFB300;">${hold} hold</span>, 
                <span style="color: #FF9800;">${sell} sell</span>, 
                <span style="color: #FF5252;">${strongSell} strong sell</span>
            `;
        } else {
            analystSummary.innerHTML = `<span style="color: #8b9bb4;">No analyst coverage available</span>`;
        }

    } catch (error) {
        console.error('Error fetching analyst sentiment:', error);
        analystSummary.innerHTML = `
            <div style="color: #8b9bb4; line-height: 1.6;">
                <strong style="color: #FFB300;">📊 Analyst Data Unavailable</strong><br>
                Unable to fetch analyst ratings from Finnhub API.<br>
                <span style="font-size: 0.9em;">Check console for details or verify at <a href="https://finance.yahoo.com/quote/${symbol}" target="_blank" style="color: #00E5FF; text-decoration: none;">Yahoo Finance ↗</a></span>
            </div>
        `;
    }
};

// Calculate and Render Ladder
const renderLadder = (prices = null, volumes = null) => {
    if (!currentStock.price) return;

    let html = '';

    // If we have price data, calculate smart support levels
    if (prices && volumes && prices.length >= 60) {
        const supportLevels = detectSupportResistanceLevels(prices, volumes, currentStock.price);

        if (supportLevels.length > 0) {
            supportLevels.forEach(level => {
                // Create type badge
                let typeBadge = '';
                let badgeColor = '#00E5FF';

                if (level.type.startsWith('pivot')) {
                    typeBadge = level.type.toUpperCase().replace('PIVOT_', '');
                    badgeColor = '#7B61FF';
                } else if (level.type === 'swing_low') {
                    typeBadge = 'SWING';
                    badgeColor = '#FFB300';
                } else if (level.type === 'fibonacci') {
                    typeBadge = 'FIB';
                    badgeColor = '#00E676';
                } else if (level.type === 'volume_profile') {
                    typeBadge = 'VOL';
                    badgeColor = '#FF9800';
                } else if (level.type === 'moving_average') {
                    typeBadge = 'MA';
                    badgeColor = '#00E5FF';
                }

                // Create strength indicator (bars)
                const strengthBars = Math.min(Math.floor(level.strength / 2), 5);
                const strengthIndicator = '🟢'.repeat(strengthBars) + '⚪'.repeat(5 - strengthBars);

                // Recommendation based on drop
                let recommendation = '';
                let recColor = '';

                if (level.dropPercent >= 25) {
                    recommendation = "Generational Buy";
                    recColor = 'text-success';
                } else if (level.dropPercent >= 20) {
                    recommendation = "Best Deal";
                    recColor = 'text-success';
                } else if (level.dropPercent >= 15) {
                    recommendation = "Good Deal";
                    recColor = 'text-success';
                } else if (level.dropPercent >= 10) {
                    recommendation = "Fair Value";
                    recColor = '';
                } else {
                    recommendation = "Wait for More";
                    recColor = 'text-neutral';
                }

                html += `
                    <tr>
                        <td><span style="background: ${badgeColor}; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 0.75em; font-weight: 700;">${typeBadge}</span></td>
                        <td class="price-target">$${level.price.toFixed(2)}</td>
                        <td style="font-weight: 600;">${level.allocation}%</td>
                        <td style="font-size: 0.85em;">
                            <span class="${recColor}" style="font-weight: 500;">${recommendation}</span>
                            <span style="color: #8b9bb4; margin-left: 6px;">— ${level.description.substring(0, 30)}${level.description.length > 30 ? '...' : ''}</span>
                        </td>
                    </tr>
                `;
            });
        } else {
            html = '<tr><td colspan="7" style="text-align:center; padding: 20px; color: #8b9bb4;">Insufficient data for support/resistance calculation</td></tr>';
        }
    } else {
        // Fallback to simple percentage-based ladder if no price data
        html = '<tr><td colspan="7" style="text-align:center; padding: 20px; color: #8b9bb4;">Loading support levels...</td></tr>';
    }

    elements.levelsList.innerHTML = html;
};


// Initialize App
// Helper to update last updated time
const updateLastUpdatedTime = () => {
    if (elements.lastUpdated) {
        const now = new Date();
        elements.lastUpdated.textContent = `Last updated: ${now.toLocaleTimeString()}`;
    }
};

// Initialize App
const init = () => {
    // Event Listeners
    if (elements.searchBtn) {
        elements.searchBtn.addEventListener('click', () => {
            const query = elements.search.value.trim().toUpperCase();
            if (query) showDetail(query);
        });
    }

    if (elements.search) {
        elements.search.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = elements.search.value.trim().toUpperCase();
                if (query) showDetail(query);
            }
        });
    }

    if (elements.backBtn) elements.backBtn.addEventListener('click', showDashboard);
    if (elements.logoBtn) elements.logoBtn.addEventListener('click', showDashboard);

    if (elements.refreshBtn) {
        elements.refreshBtn.addEventListener('click', () => {
            elements.refreshBtn.classList.add('spinning');

            // Invalidate all cache
            WATCHLIST.forEach(symbol => dataManager.invalidate(symbol));

            // Refresh current view
            if (!elements.dashboardView.classList.contains('hidden')) {
                initDashboard().then(() => {
                    setTimeout(() => elements.refreshBtn.classList.remove('spinning'), 500);
                });
            } else if (currentStock.symbol) {
                updateStock(currentStock.symbol).then(() => {
                    setTimeout(() => elements.refreshBtn.classList.remove('spinning'), 500);
                });
            }
            updateLastUpdatedTime();
        });
    }

    // Auto-Refresh Loop (60s)
    setInterval(() => {
        console.log("Auto-refreshing data...");
        if (!elements.dashboardView.classList.contains('hidden')) {
            initDashboard();
        } else if (currentStock.symbol) {
            updateStock(currentStock.symbol);
        }
        updateLastUpdatedTime();
    }, 60000);

    // Initial Load
    showDashboard();
    updateLastUpdatedTime();

    // Initialize simulation controls
    initSimulationControls();
};

init();
